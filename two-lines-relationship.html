<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>空間図形：5つの立体シミュレーター</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: sans-serif; }
        #canvas-container { width: 100%; height: 100vh; position: relative; }
        
        #ui-panel {
            position: absolute; top: 10px; right: 10px;
            background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(5px);
            padding: 12px; border-radius: 10px; width: 240px; z-index: 100;
        }
        .mode-selector { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 10px; }
        .mode-btn {
            flex: 1 1 30%; padding: 6px 2px; font-size: 10px; cursor: pointer;
            background: #eee; border: 1px solid #ccc; border-radius: 4px;
        }
        .mode-btn.active { background: #FF5555; color: white; border-color: #FF5555; font-weight: bold; }
        
        h1 { margin: 0 0 8px 0; font-size: 14px; text-align: center; border-bottom: 1px solid #999; }
        #result-display {
            font-size: 18px; font-weight: bold; text-align: center; min-height: 24px; margin: 10px 0;
            padding: 5px; border-radius: 5px;
        }
        .res-p { color: #27ae60; background: rgba(39, 174, 96, 0.1); } 
        .res-i { color: #2980b9; background: rgba(41, 128, 185, 0.1); } 
        .res-s { color: #c0392b; background: rgba(192, 57, 43, 0.1); }
        
        #reset-btn { width: 100%; padding: 8px; border-radius: 20px; background: #333; color: white; cursor: pointer; border: none; font-size: 12px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="canvas-container">
        <div id="ui-panel">
            <h1>立体を選択</h1>
            <div class="mode-selector">
                <button class="mode-btn active" onclick="changeSolid('cube')">立方体</button>
                <button class="mode-btn" onclick="changeSolid('prism')">三角柱</button>
                <button class="mode-btn" onclick="changeSolid('pyramid')">四角錐</button>
                <button class="mode-btn" onclick="changeSolid('trapezoid')">台形柱</button>
                <button class="mode-btn" onclick="changeSolid('lshape')">L字型</button>
            </div>
            <div id="selection-status" style="font-size:11px; color:#555; text-align:center;">辺を2本選ぼう</div>
            <div id="result-display"></div>
            <button id="reset-btn" onclick="resetSelection()">リセット</button>
        </div>
    </div>

    <script>
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        const camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 1000);
        camera.position.set(10, 10, 15);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        scene.add(new THREE.AmbientLight(0xffffff, 0.9));

        const solids = {
            cube: {
                v: { A:[-2,2,2], B:[2,2,2], C:[2,2,-2], D:[-2,2,-2], E:[-2,-2,2], F:[2,-2,2], G:[2,-2,-2], H:[-2,-2,-2] },
                e: [["A","B"],["B","C"],["C","D"],["D","A"], ["E","F"],["F","G"],["G","H"],["H","E"], ["A","E"],["B","F"],["C","G"],["D","H"]]
            },
            prism: {
                v: { A:[0,2,2], B:[2,2,-1], C:[-2,2,-1], D:[0,-2,2], E:[2,-2,-1], F:[-2,-2,-1] },
                e: [["A","B"],["B","C"],["C","A"], ["D","E"],["E","F"],["F","D"], ["A","D"],["B","E"],["C","F"]]
            },
            pyramid: {
                v: { O:[0,2.5,0], A:[-2,-1,2], B:[2,-1,2], C:[2,-1,-2], D:[-2,-1,-2] },
                e: [["O","A"],["O","B"],["O","C"],["O","D"], ["A","B"],["B","C"],["C","D"],["D","A"]]
            },
            trapezoid: {
                v: { A:[-1, 2, 2], B:[ 2, 2, 2], C:[ 2, 2, -2], D:[-1, 2, -2], E:[-3, -2, 2], F:[ 3, -2, 2], G:[ 3, -2, -2], H:[-3, -2, -2] },
                e: [["A","B"],["B","C"],["C","D"],["D","A"], ["E","F"],["F","G"],["G","H"],["H","E"], ["A","E"],["B","F"],["C","G"],["D","H"]]
            },
            lshape: {
                v: { 
                    A:[-2, 2, 2], B:[ 1, 2, 2], C:[ 1, 2, 0], D:[ 3, 2, 0], E:[ 3, 2,-2], F:[-2, 2,-2],
                    G:[-2,-2, 2], H:[ 1,-2, 2], I:[ 1,-2, 0], J:[ 3,-2, 0], K:[ 3,-2,-2], L:[-2,-2,-2]
                },
                e: [
                    ["A","B"],["B","C"],["C","D"],["D","E"],["E","F"],["F","A"], // 上面
                    ["G","H"],["H","I"],["I","J"],["J","K"],["K","L"],["L","G"], // 下面
                    ["A","G"],["B","H"],["C","I"],["D","J"],["E","K"],["F","L"]  // 柱
                ]
            }
        };

        let edgeMeshes = [];
        let sprites = [];
        let selected = [];

        function createTextSprite(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white'; ctx.font = 'Bold 70px Arial'; ctx.textAlign = 'center';
            ctx.shadowColor = "black"; ctx.shadowBlur = 8;
            ctx.fillText(text, 64, 80);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            sprite.scale.set(1.2, 1.2, 1);
            return sprite;
        }

        function initSolid(type) {
            edgeMeshes.forEach(m => scene.remove(m));
            sprites.forEach(s => scene.remove(s));
            edgeMeshes = []; sprites = []; selected = [];
            resetUI();

            const data = solids[type];
            for (const [name, pos] of Object.entries(data.v)) {
                const s = createTextSprite(name);
                s.position.set(pos[0]*1.15, pos[1]*1.15, pos[2]*1.15);
                scene.add(s);
                sprites.push(s);
            }
            data.e.forEach(pair => {
                const v1 = new THREE.Vector3(...data.v[pair[0]]);
                const v2 = new THREE.Vector3(...data.v[pair[1]]);
                const dir = v2.clone().sub(v1);
                const geo = new THREE.CylinderGeometry(0.12, 0.12, dir.length(), 12);
                const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x888888, transparent:true, opacity:0.6 }));
                mesh.position.copy(v1.clone().lerp(v2, 0.5));
                mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize());
                mesh.userData = { v1: pair[0], v2: pair[1], dir: dir.clone().normalize() };
                scene.add(mesh);
                edgeMeshes.push(mesh);
            });
        }

        window.changeSolid = (type) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            initSolid(type);
        };

        function checkRelation() {
            const e1 = selected[0].userData;
            const e2 = selected[1].userData;
            const res = document.getElementById('result-display');
            if (e1.v1 === e2.v1 || e1.v1 === e2.v2 || e1.v2 === e2.v1 || e1.v2 === e2.v2) {
                res.textContent = "交わる"; res.className = "res-i"; return;
            }
            const dot = Math.abs(e1.dir.dot(e2.dir));
            if (dot > 0.999) {
                res.textContent = "平行"; res.className = "res-p"; return;
            }
            res.textContent = "ねじれの位置"; res.className = "res-s";
        }

        window.addEventListener('pointerdown', (e) => {
            if (selected.length >= 2) return;
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(edgeMeshes);
            if (hits.length > 0) {
                const m = hits[0].object;
                if (!selected.includes(m)) {
                    m.material.color.set(0xffcc00); m.material.opacity = 1;
                    selected.push(m);
                    if (selected.length === 2) checkRelation();
                }
            }
        });

        function resetUI() { document.getElementById('result-display').textContent = ""; document.getElementById('result-display').className = ""; }
        window.resetSelection = () => { edgeMeshes.forEach(m => { m.material.color.set(0x888888); m.material.opacity = 0.6; }); selected = []; resetUI(); };
        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
        initSolid('cube'); animate();
        window.addEventListener('resize', () => { renderer.setSize(container.clientWidth, container.clientHeight); camera.aspect = container.clientWidth/container.clientHeight; camera.updateProjectionMatrix(); });
    </script>
</body>
</html>