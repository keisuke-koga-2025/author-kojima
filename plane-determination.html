<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>平面決定・座標完全固定版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: sans-serif; }
        #canvas-container { width: 100%; height: 100vh; position: relative; }
        
        #ui-layer {
            position: absolute; bottom: 20px; width: 100%;
            display: flex; flex-direction: column; align-items: center; gap: 15px;
            pointer-events: none;
        }

        .control-panel {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            padding: 15px 30px; border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex; gap: 30px; align-items: center;
            pointer-events: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .slider-box { text-align: center; color: white; }
        .label { font-size: 12px; margin-bottom: 8px; color: #ddd; display: block; font-weight: bold; }
        input[type=range] { width: 150px; cursor: pointer; accent-color: #FF5555; }

        .mode-buttons {
            display: flex; gap: 10px; pointer-events: auto;
        }
        button {
            background: rgba(255, 255, 255, 0.1); color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 16px; border-radius: 30px; cursor: pointer;
            font-size: 14px; transition: 0.2s;
        }
        button:hover { background: rgba(255, 255, 255, 0.3); }
        button.active { background: #4ECDC4; color: #000; font-weight: bold; border: none; }

        #warning {
            position: absolute; top: 20%; width: 100%; text-align: center;
            font-size: 28px; font-weight: bold; color: #ff3333;
            text-shadow: 0 0 15px black; pointer-events: none; opacity: 0;
            transition: opacity 0.2s;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="canvas-container">
        <div id="warning">WARNING: 平面崩壊</div>
        
        <div id="ui-layer">
            <div class="control-panel">
                <div class="slider-box">
                    <span class="label">力加減 A (タテ)</span>
                    <input type="range" id="sliderX" min="-100" max="100" value="0">
                </div>
                <div class="slider-box">
                    <span class="label">力加減 B (ヨコ)</span>
                    <input type="range" id="sliderZ" min="-100" max="100" value="0">
                </div>
            </div>
            
            <div class="mode-buttons">
                <button onclick="setMode(1)" id="btn1" class="active">1点 (自由)</button>
                <button onclick="setMode(2)" id="btn2">2点 (直線)</button>
                <button onclick="setMode(3)" id="btn3">3点 (固定)</button>
            </div>
        </div>
    </div>

    <script>
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        
        const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(0, 9, 13);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // ライト
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);
        scene.add(new THREE.AmbientLight(0x404040));

        // グリッド
        const grid = new THREE.GridHelper(30, 30, 0x444444, 0x333333);
        scene.add(grid);

        // --- 釘（点）の位置定義 ---
        // 計算で使う座標と、表示する座標を完全に一致させる
        // A:左側(-3,0), B:右側(3,0), C:手前(0, 3.5)
        // ※Plane上ではY軸が奥行き(World Z)に対応
        const localA = { x: -3, y: 0 };
        const localB = { x: 3, y: 0 };
        const localC = { x: 0, y: 3.5 };

        const sphereGeo = new THREE.SphereGeometry(0.25, 32, 32);
        const pinMat = new THREE.MeshStandardMaterial({ color: 0xFF4444, roughness: 0.2, emissive: 0x330000 });
        
        const pinA = new THREE.Mesh(sphereGeo, pinMat); 
        pinA.position.set(localA.x, 0, localA.y); // World座標
        
        const pinB = new THREE.Mesh(sphereGeo, pinMat); 
        pinB.position.set(localB.x, 0, localB.y);
        
        const pinC = new THREE.Mesh(sphereGeo, pinMat); 
        pinC.position.set(localC.x, 0, localC.y);

        // --- 平面（ガラス板） ---
        const planeGeo = new THREE.PlaneGeometry(14, 12, 40, 40); // 40x40分割
        
        const basePos = [];
        const posAttr = planeGeo.attributes.position;
        for(let i=0; i<posAttr.count; i++){
            // 初期状態の頂点を保存
            basePos.push(new THREE.Vector3(posAttr.getX(i), posAttr.getY(i), posAttr.getZ(i)));
        }

        const glassMat = new THREE.MeshPhysicalMaterial({
            color: 0x88CCFF, 
            metalness: 0.1, roughness: 0.05, transmission: 0.7, opacity: 0.9, transparent: true,
            side: THREE.DoubleSide
        });
        const plane = new THREE.Mesh(planeGeo, glassMat);
        plane.rotation.x = -Math.PI / 2; // 寝かせる
        
        const wireGeo = new THREE.WireframeGeometry(planeGeo);
        const wireLine = new THREE.LineSegments(wireGeo);
        wireLine.material.color.set(0xffffff);
        wireLine.material.opacity = 0.1;
        wireLine.material.transparent = true;
        plane.add(wireLine);

        const pivot = new THREE.Group();
        pivot.add(plane);
        scene.add(pivot);
        scene.add(pinA);

        // --- 破片 ---
        const fragGroup = new THREE.Group();
        scene.add(fragGroup);
        let fragments = [];

        function createShards() {
            fragGroup.clear();
            fragments = [];
            const count = 50;
            for(let i=0; i<count; i++) {
                const geo = new THREE.TetrahedronGeometry(Math.random()*0.6 + 0.2);
                const mat = glassMat.clone();
                mat.opacity = 0.9;
                const mesh = new THREE.Mesh(geo, mat);
                mesh.visible = false;
                fragGroup.add(mesh);
                fragments.push({
                    mesh: mesh,
                    vel: new THREE.Vector3((Math.random()-0.5)*2, Math.random()+0.5, (Math.random()-0.5)*2),
                    rot: new THREE.Vector3(Math.random()*0.5, Math.random()*0.5, Math.random()*0.5),
                    active: false
                });
            }
        }
        createShards();

        let mode = 1;
        let isBroken = false;
        const sliderX = document.getElementById('sliderX');
        const sliderZ = document.getElementById('sliderZ');
        const warning = document.getElementById('warning');
        const btns = [document.getElementById('btn1'), document.getElementById('btn2'), document.getElementById('btn3')];

        window.setMode = function(m) {
            mode = m;
            isBroken = false;
            sliderX.value = 0;
            sliderZ.value = 0;
            warning.style.opacity = 0;
            
            scene.remove(pinB); scene.remove(pinC);
            if(mode >= 2) scene.add(pinB);
            if(mode >= 3) scene.add(pinC);

            // リセット
            pivot.rotation.set(0,0,0);
            plane.visible = true;
            for(let i=0; i<posAttr.count; i++){
                posAttr.setXYZ(i, basePos[i].x, basePos[i].y, basePos[i].z);
            }
            posAttr.needsUpdate = true;
            glassMat.color.setHex(0x88CCFF);
            
            fragments.forEach(f => { f.active = false; f.mesh.visible = false; });
            
            btns.forEach(b => b.classList.remove('active'));
            btns[m-1].classList.add('active');
        }

        function breakGlass() {
            if(isBroken) return;
            isBroken = true;
            plane.visible = false;
            warning.innerText = "CRASH!!";
            warning.style.opacity = 1;
            setTimeout(() => { warning.style.opacity = 0; }, 1000);
            
            fragments.forEach(f => {
                f.active = true;
                f.mesh.visible = true;
                f.mesh.position.set((Math.random()-0.5)*10, 0, (Math.random()-0.5)*8);
                f.vel.y = Math.random() * 0.5 + 0.2;
            });
            pinA.visible = false; pinB.visible = false; pinC.visible = false;
            setTimeout(() => { 
                if(!isBroken) return;
                pinA.visible = true; pinB.visible = mode>=2; pinC.visible = mode>=3; 
            }, 1500);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if(!isBroken) {
                const valX = parseInt(sliderX.value);
                const valZ = parseInt(sliderZ.value);
                let stress = 0;

                // --- 頂点変形計算 ---
                for(let i=0; i<posAttr.count; i++) {
                    const x = basePos[i].x; // Plane上の横位置
                    const y = basePos[i].y; // Plane上の奥行位置 (World Z)
                    let z = 0;              // 高さ (変位量)

                    if (mode === 1) {
                        // 1点 (自由)
                        // ピボット回転(pivot.rotation)を使わず、頂点計算で回転させる
                        // これにより、確実に Point A (localA) を通る平面を作れる
                        // 式: Z = SlopeX * (x - Ax) + SlopeY * (y - Ay)
                        // x=Ax, y=Ay のとき Z=0 となり、確実に点を通る
                        
                        const tiltX = valX * 0.03; // 傾き係数
                        const tiltY = valZ * 0.03;
                        
                        z = tiltY * (x - localA.x) + tiltX * (y - localA.y);
                        
                        // 1点留めは自由なのでストレスなし
                        stress = 0;
                    } 
                    else if (mode === 2) {
                        // 2点 (直線固定 + ねじれ)
                        // 軸回転(ドア)の動き
                        const doorAngle = valX * 0.02;
                        // ドア回転成分: Z = Angle * (y) ?? いや、軸はy=0
                        // 単純な回転: z += y * sin(angle) 近似
                        z += y * doorAngle;

                        // ねじれ成分 (ここが前回と同じ、雑巾絞り)
                        // xの位置に応じて回転方向が逆転する
                        const twistStrength = valZ * 0.003;
                        z += y * (x * twistStrength); 

                        // 軸上 (y=0) では z=0 になるので、A(-3,0)もB(3,0)も動かない！
                        stress = Math.abs(valZ) / 80;
                    } 
                    else if (mode === 3) {
                        // 3点固定
                        const distA = Math.sqrt((x - localA.x)**2 + (y - localA.y)**2);
                        const distB = Math.sqrt((x - localB.x)**2 + (y - localB.y)**2);
                        const distC = Math.sqrt((x - localC.x)**2 + (y - localC.y)**2);
                        const minDist = Math.min(distA, distB, distC);
                        
                        const weight = Math.pow(minDist, 1.8) * 0.1;
                        const wave = Math.sin(x + valX*0.1) * Math.cos(y + valZ*0.1) * (Math.abs(valX)+Math.abs(valZ)) * 0.02;
                        z = wave * weight;

                        stress = (Math.abs(valX) + Math.abs(valZ)) / 120;
                    }

                    posAttr.setZ(i, z);
                }
                posAttr.needsUpdate = true;

                // 色と破壊判定
                if (mode > 1) {
                    if (stress > 0.2) {
                        const r = 0.5 + stress * 0.5;
                        const g = 0.8 - stress * 0.8;
                        const b = 1.0 - stress * 1.0;
                        glassMat.color.setRGB(r, g, b);
                        warning.innerText = "WARNING: 負荷増大";
                        warning.style.opacity = (stress > 0.7) ? 1 : 0;
                        if (stress > 1.0) breakGlass();
                    } else {
                        glassMat.color.setHex(0x88CCFF);
                        warning.style.opacity = 0;
                    }
                } else {
                    // モード1は常に青（自由なので）
                    glassMat.color.setHex(0x88CCFF);
                }

            } else {
                fragments.forEach(f => {
                    if(f.active) {
                        f.mesh.position.add(f.vel);
                        f.mesh.rotation.x += f.rot.x;
                        f.mesh.rotation.y += f.rot.y;
                        f.vel.y -= 0.03;
                        if(f.mesh.position.y < -15) f.active = false;
                    }
                });
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            const w = container.clientWidth;
            const h = container.clientHeight;
            renderer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>